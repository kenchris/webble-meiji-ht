{"version":3,"file":"inert-6aad2249.js","sources":["../../node_modules/blocking-elements/dist/blocking-elements.js","../../node_modules/wicg-inert/src/inert.js"],"sourcesContent":["/**\n * @license\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n(() => {\n    var _a, _b, _c;\n    /* Symbols for private properties */\n    const _blockingElements = Symbol();\n    const _alreadyInertElements = Symbol();\n    const _topElParents = Symbol();\n    const _siblingsToRestore = Symbol();\n    const _parentMO = Symbol();\n    /* Symbols for private static methods */\n    const _topChanged = Symbol();\n    const _swapInertedSibling = Symbol();\n    const _inertSiblings = Symbol();\n    const _restoreInertedSiblings = Symbol();\n    const _getParents = Symbol();\n    const _getDistributedChildren = Symbol();\n    const _isInertable = Symbol();\n    const _handleMutations = Symbol();\n    class BlockingElementsImpl {\n        constructor() {\n            /**\n             * The blocking elements.\n             */\n            this[_a] = [];\n            /**\n             * Used to keep track of the parents of the top element, from the element\n             * itself up to body. When top changes, the old top might have been removed\n             * from the document, so we need to memoize the inerted parents' siblings\n             * in order to restore their inerteness when top changes.\n             */\n            this[_b] = [];\n            /**\n             * Elements that are already inert before the first blocking element is\n             * pushed.\n             */\n            this[_c] = new Set();\n        }\n        destructor() {\n            // Restore original inertness.\n            this[_restoreInertedSiblings](this[_topElParents]);\n            // Note we don't want to make these properties nullable on the class,\n            // since then we'd need non-null casts in many places. Calling a method on\n            // a BlockingElements instance after calling destructor will result in an\n            // exception.\n            const nullable = this;\n            nullable[_blockingElements] = null;\n            nullable[_topElParents] = null;\n            nullable[_alreadyInertElements] = null;\n        }\n        get top() {\n            const elems = this[_blockingElements];\n            return elems[elems.length - 1] || null;\n        }\n        push(element) {\n            if (!element || element === this.top) {\n                return;\n            }\n            // Remove it from the stack, we'll bring it to the top.\n            this.remove(element);\n            this[_topChanged](element);\n            this[_blockingElements].push(element);\n        }\n        remove(element) {\n            const i = this[_blockingElements].indexOf(element);\n            if (i === -1) {\n                return false;\n            }\n            this[_blockingElements].splice(i, 1);\n            // Top changed only if the removed element was the top element.\n            if (i === this[_blockingElements].length) {\n                this[_topChanged](this.top);\n            }\n            return true;\n        }\n        pop() {\n            const top = this.top;\n            top && this.remove(top);\n            return top;\n        }\n        has(element) {\n            return this[_blockingElements].indexOf(element) !== -1;\n        }\n        /**\n         * Sets `inert` to all document elements except the new top element, its\n         * parents, and its distributed content.\n         */\n        [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {\n            const toKeepInert = this[_alreadyInertElements];\n            const oldParents = this[_topElParents];\n            // No new top, reset old top if any.\n            if (!newTop) {\n                this[_restoreInertedSiblings](oldParents);\n                toKeepInert.clear();\n                this[_topElParents] = [];\n                return;\n            }\n            const newParents = this[_getParents](newTop);\n            // New top is not contained in the main document!\n            if (newParents[newParents.length - 1].parentNode !== document.body) {\n                throw Error('Non-connected element cannot be a blocking element');\n            }\n            // Cast here because we know we'll call _inertSiblings on newParents\n            // below.\n            this[_topElParents] = newParents;\n            const toSkip = this[_getDistributedChildren](newTop);\n            // No previous top element.\n            if (!oldParents.length) {\n                this[_inertSiblings](newParents, toSkip, toKeepInert);\n                return;\n            }\n            let i = oldParents.length - 1;\n            let j = newParents.length - 1;\n            // Find common parent. Index 0 is the element itself (so stop before it).\n            while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {\n                i--;\n                j--;\n            }\n            // If up the parents tree there are 2 elements that are siblings, swap\n            // the inerted sibling.\n            if (oldParents[i] !== newParents[j]) {\n                this[_swapInertedSibling](oldParents[i], newParents[j]);\n            }\n            // Restore old parents siblings inertness.\n            i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i));\n            // Make new parents siblings inert.\n            j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);\n        }\n        /**\n         * Swaps inertness between two sibling elements.\n         * Sets the property `inert` over the attribute since the inert spec\n         * doesn't specify if it should be reflected.\n         * https://html.spec.whatwg.org/multipage/interaction.html#inert\n         */\n        [_swapInertedSibling](oldInert, newInert) {\n            const siblingsToRestore = oldInert[_siblingsToRestore];\n            // oldInert is not contained in siblings to restore, so we have to check\n            // if it's inertable and if already inert.\n            if (this[_isInertable](oldInert) && !oldInert.inert) {\n                oldInert.inert = true;\n                siblingsToRestore.add(oldInert);\n            }\n            // If newInert was already between the siblings to restore, it means it is\n            // inertable and must be restored.\n            if (siblingsToRestore.has(newInert)) {\n                newInert.inert = false;\n                siblingsToRestore.delete(newInert);\n            }\n            newInert[_parentMO] = oldInert[_parentMO];\n            newInert[_siblingsToRestore] = siblingsToRestore;\n            oldInert[_parentMO] = undefined;\n            oldInert[_siblingsToRestore] = undefined;\n        }\n        /**\n         * Restores original inertness to the siblings of the elements.\n         * Sets the property `inert` over the attribute since the inert spec\n         * doesn't specify if it should be reflected.\n         * https://html.spec.whatwg.org/multipage/interaction.html#inert\n         */\n        [_restoreInertedSiblings](elements) {\n            for (const element of elements) {\n                const mo = element[_parentMO];\n                mo.disconnect();\n                element[_parentMO] = undefined;\n                const siblings = element[_siblingsToRestore];\n                for (const sibling of siblings) {\n                    sibling.inert = false;\n                }\n                element[_siblingsToRestore] = undefined;\n            }\n        }\n        /**\n         * Inerts the siblings of the elements except the elements to skip. Stores\n         * the inerted siblings into the element's symbol `_siblingsToRestore`.\n         * Pass `toKeepInert` to collect the already inert elements.\n         * Sets the property `inert` over the attribute since the inert spec\n         * doesn't specify if it should be reflected.\n         * https://html.spec.whatwg.org/multipage/interaction.html#inert\n         */\n        [_inertSiblings](elements, toSkip, toKeepInert) {\n            for (const element of elements) {\n                // Assume element is not a Document, so it must have a parentNode.\n                const parent = element.parentNode;\n                const children = parent.children;\n                const inertedSiblings = new Set();\n                for (let j = 0; j < children.length; j++) {\n                    const sibling = children[j];\n                    // Skip the input element, if not inertable or to be skipped.\n                    if (sibling === element || !this[_isInertable](sibling) ||\n                        (toSkip && toSkip.has(sibling))) {\n                        continue;\n                    }\n                    // Should be collected since already inerted.\n                    if (toKeepInert && sibling.inert) {\n                        toKeepInert.add(sibling);\n                    }\n                    else {\n                        sibling.inert = true;\n                        inertedSiblings.add(sibling);\n                    }\n                }\n                // Store the siblings that were inerted.\n                element[_siblingsToRestore] = inertedSiblings;\n                // Observe only immediate children mutations on the parent.\n                const mo = new MutationObserver(this[_handleMutations].bind(this));\n                element[_parentMO] = mo;\n                let parentToObserve = parent;\n                // If we're using the ShadyDOM polyfill, then our parent could be a\n                // shady root, which is an object that acts like a ShadowRoot, but isn't\n                // actually a node in the real DOM. Observe the real DOM parent instead.\n                const maybeShadyRoot = parentToObserve;\n                if (maybeShadyRoot.__shady && maybeShadyRoot.host) {\n                    parentToObserve = maybeShadyRoot.host;\n                }\n                mo.observe(parentToObserve, {\n                    childList: true,\n                });\n            }\n        }\n        /**\n         * Handles newly added/removed nodes by toggling their inertness.\n         * It also checks if the current top Blocking Element has been removed,\n         * notifying and removing it.\n         */\n        [_handleMutations](mutations) {\n            const parents = this[_topElParents];\n            const toKeepInert = this[_alreadyInertElements];\n            for (const mutation of mutations) {\n                // If the target is a shadowRoot, get its host as we skip shadowRoots when\n                // computing _topElParents.\n                const target = mutation.target.host || mutation.target;\n                const idx = target === document.body ?\n                    parents.length :\n                    parents.indexOf(target);\n                const inertedChild = parents[idx - 1];\n                const inertedSiblings = inertedChild[_siblingsToRestore];\n                // To restore.\n                for (let i = 0; i < mutation.removedNodes.length; i++) {\n                    const sibling = mutation.removedNodes[i];\n                    if (sibling === inertedChild) {\n                        console.info('Detected removal of the top Blocking Element.');\n                        this.pop();\n                        return;\n                    }\n                    if (inertedSiblings.has(sibling)) {\n                        sibling.inert = false;\n                        inertedSiblings.delete(sibling);\n                    }\n                }\n                // To inert.\n                for (let i = 0; i < mutation.addedNodes.length; i++) {\n                    const sibling = mutation.addedNodes[i];\n                    if (!this[_isInertable](sibling)) {\n                        continue;\n                    }\n                    if (toKeepInert && sibling.inert) {\n                        toKeepInert.add(sibling);\n                    }\n                    else {\n                        sibling.inert = true;\n                        inertedSiblings.add(sibling);\n                    }\n                }\n            }\n        }\n        /**\n         * Returns if the element is inertable.\n         */\n        [_isInertable](element) {\n            return false === /^(style|template|script)$/.test(element.localName);\n        }\n        /**\n         * Returns the list of newParents of an element, starting from element\n         * (included) up to `document.body` (excluded).\n         */\n        [_getParents](element) {\n            const parents = [];\n            let current = element;\n            // Stop to body.\n            while (current && current !== document.body) {\n                // Skip shadow roots.\n                if (current.nodeType === Node.ELEMENT_NODE) {\n                    parents.push(current);\n                }\n                // ShadowDom v1\n                if (current.assignedSlot) {\n                    // Collect slots from deepest slot to top.\n                    while (current = current.assignedSlot) {\n                        parents.push(current);\n                    }\n                    // Continue the search on the top slot.\n                    current = parents.pop();\n                    continue;\n                }\n                current = current.parentNode ||\n                    current.host;\n            }\n            return parents;\n        }\n        /**\n         * Returns the distributed children of the element's shadow root.\n         * Returns null if the element doesn't have a shadow root.\n         */\n        [_getDistributedChildren](element) {\n            const shadowRoot = element.shadowRoot;\n            if (!shadowRoot) {\n                return null;\n            }\n            const result = new Set();\n            let i;\n            let j;\n            let nodes;\n            const slots = shadowRoot.querySelectorAll('slot');\n            if (slots.length && slots[0].assignedNodes) {\n                for (i = 0; i < slots.length; i++) {\n                    nodes = slots[i].assignedNodes({\n                        flatten: true,\n                    });\n                    for (j = 0; j < nodes.length; j++) {\n                        if (nodes[j].nodeType === Node.ELEMENT_NODE) {\n                            result.add(nodes[j]);\n                        }\n                    }\n                }\n                // No need to search for <content>.\n            }\n            return result;\n        }\n    }\n    document.$blockingElements =\n        new BlockingElementsImpl();\n})();\n//# sourceMappingURL=blocking-elements.js.map","/**\n * This work is licensed under the W3C Software and Document License\n * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).\n */\n\n// Convenience function for converting NodeLists.\n/** @type {typeof Array.prototype.slice} */\nconst slice = Array.prototype.slice;\n\n/**\n * IE has a non-standard name for \"matches\".\n * @type {typeof Element.prototype.matches}\n */\nconst matches =\n    Element.prototype.matches || Element.prototype.msMatchesSelector;\n\n/** @type {string} */\nconst _focusableElementsString = ['a[href]',\n                                  'area[href]',\n                                  'input:not([disabled])',\n                                  'select:not([disabled])',\n                                  'textarea:not([disabled])',\n                                  'button:not([disabled])',\n                                  'details',\n                                  'summary',\n                                  'iframe',\n                                  'object',\n                                  'embed',\n                                  '[contenteditable]'].join(',');\n\n/**\n * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`\n * attribute.\n *\n * Its main functions are:\n *\n * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the\n *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering\n *   each focusable node in the subtree with the singleton `InertManager` which manages all known\n *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`\n *   instance exists for each focusable node which has at least one inert root as an ancestor.\n *\n * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`\n *   attribute is removed from the root node). This is handled in the destructor, which calls the\n *   `deregister` method on `InertManager` for each managed inert node.\n */\nclass InertRoot {\n  /**\n   * @param {!Element} rootElement The Element at the root of the inert subtree.\n   * @param {!InertManager} inertManager The global singleton InertManager object.\n   */\n  constructor(rootElement, inertManager) {\n    /** @type {!InertManager} */\n    this._inertManager = inertManager;\n\n    /** @type {!Element} */\n    this._rootElement = rootElement;\n\n    /**\n     * @type {!Set<!InertNode>}\n     * All managed focusable nodes in this InertRoot's subtree.\n     */\n    this._managedNodes = new Set();\n\n    // Make the subtree hidden from assistive technology\n    if (this._rootElement.hasAttribute('aria-hidden')) {\n      /** @type {?string} */\n      this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');\n    } else {\n      this._savedAriaHidden = null;\n    }\n    this._rootElement.setAttribute('aria-hidden', 'true');\n\n    // Make all focusable elements in the subtree unfocusable and add them to _managedNodes\n    this._makeSubtreeUnfocusable(this._rootElement);\n\n    // Watch for:\n    // - any additions in the subtree: make them unfocusable too\n    // - any removals from the subtree: remove them from this inert root's managed nodes\n    // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable\n    //   element, make that node a managed node.\n    this._observer = new MutationObserver(this._onMutation.bind(this));\n    this._observer.observe(this._rootElement, {attributes: true, childList: true, subtree: true});\n  }\n\n  /**\n   * Call this whenever this object is about to become obsolete.  This unwinds all of the state\n   * stored in this object and updates the state of all of the managed nodes.\n   */\n  destructor() {\n    this._observer.disconnect();\n\n    if (this._rootElement) {\n      if (this._savedAriaHidden !== null) {\n        this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);\n      } else {\n        this._rootElement.removeAttribute('aria-hidden');\n      }\n    }\n\n    this._managedNodes.forEach(function(inertNode) {\n      this._unmanageNode(inertNode.node);\n    }, this);\n\n    // Note we cast the nulls to the ANY type here because:\n    // 1) We want the class properties to be declared as non-null, or else we\n    //    need even more casts throughout this code. All bets are off if an\n    //    instance has been destroyed and a method is called.\n    // 2) We don't want to cast \"this\", because we want type-aware optimizations\n    //    to know which properties we're setting.\n    this._observer = /** @type {?} */ (null);\n    this._rootElement = /** @type {?} */ (null);\n    this._managedNodes = /** @type {?} */ (null);\n    this._inertManager = /** @type {?} */ (null);\n  }\n\n  /**\n   * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.\n   */\n  get managedNodes() {\n    return new Set(this._managedNodes);\n  }\n\n  /** @return {boolean} */\n  get hasSavedAriaHidden() {\n    return this._savedAriaHidden !== null;\n  }\n\n  /** @param {?string} ariaHidden */\n  set savedAriaHidden(ariaHidden) {\n    this._savedAriaHidden = ariaHidden;\n  }\n\n  /** @return {?string} */\n  get savedAriaHidden() {\n    return this._savedAriaHidden;\n  }\n\n  /**\n   * @param {!Node} startNode\n   */\n  _makeSubtreeUnfocusable(startNode) {\n    composedTreeWalk(startNode, (node) => this._visitNode(node));\n\n    let activeElement = document.activeElement;\n\n    if (!document.body.contains(startNode)) {\n      // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.\n      let node = startNode;\n      /** @type {!ShadowRoot|undefined} */\n      let root = undefined;\n      while (node) {\n        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n          root = /** @type {!ShadowRoot} */ (node);\n          break;\n        }\n        node = node.parentNode;\n      }\n      if (root) {\n        activeElement = root.activeElement;\n      }\n    }\n    if (startNode.contains(activeElement)) {\n      activeElement.blur();\n      // In IE11, if an element is already focused, and then set to tabindex=-1\n      // calling blur() will not actually move the focus.\n      // To work around this we call focus() on the body instead.\n      if (activeElement === document.activeElement) {\n        document.body.focus();\n      }\n    }\n  }\n\n  /**\n   * @param {!Node} node\n   */\n  _visitNode(node) {\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n      return;\n    }\n    const element = /** @type {!Element} */ (node);\n\n    // If a descendant inert root becomes un-inert, its descendants will still be inert because of\n    // this inert root, so all of its managed nodes need to be adopted by this InertRoot.\n    if (element !== this._rootElement && element.hasAttribute('inert')) {\n      this._adoptInertRoot(element);\n    }\n\n    if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {\n      this._manageNode(element);\n    }\n  }\n\n  /**\n   * Register the given node with this InertRoot and with InertManager.\n   * @param {!Node} node\n   */\n  _manageNode(node) {\n    const inertNode = this._inertManager.register(node, this);\n    this._managedNodes.add(inertNode);\n  }\n\n  /**\n   * Unregister the given node with this InertRoot and with InertManager.\n   * @param {!Node} node\n   */\n  _unmanageNode(node) {\n    const inertNode = this._inertManager.deregister(node, this);\n    if (inertNode) {\n      this._managedNodes.delete(inertNode);\n    }\n  }\n\n  /**\n   * Unregister the entire subtree starting at `startNode`.\n   * @param {!Node} startNode\n   */\n  _unmanageSubtree(startNode) {\n    composedTreeWalk(startNode, (node) => this._unmanageNode(node));\n  }\n\n  /**\n   * If a descendant node is found with an `inert` attribute, adopt its managed nodes.\n   * @param {!Element} node\n   */\n  _adoptInertRoot(node) {\n    let inertSubroot = this._inertManager.getInertRoot(node);\n\n    // During initialisation this inert root may not have been registered yet,\n    // so register it now if need be.\n    if (!inertSubroot) {\n      this._inertManager.setInert(node, true);\n      inertSubroot = this._inertManager.getInertRoot(node);\n    }\n\n    inertSubroot.managedNodes.forEach(function(savedInertNode) {\n      this._manageNode(savedInertNode.node);\n    }, this);\n  }\n\n  /**\n   * Callback used when mutation observer detects subtree additions, removals, or attribute changes.\n   * @param {!Array<!MutationRecord>} records\n   * @param {!MutationObserver} self\n   */\n  _onMutation(records, self) {\n    records.forEach(function(record) {\n      const target = /** @type {!Element} */ (record.target);\n      if (record.type === 'childList') {\n        // Manage added nodes\n        slice.call(record.addedNodes).forEach(function(node) {\n          this._makeSubtreeUnfocusable(node);\n        }, this);\n\n        // Un-manage removed nodes\n        slice.call(record.removedNodes).forEach(function(node) {\n          this._unmanageSubtree(node);\n        }, this);\n      } else if (record.type === 'attributes') {\n        if (record.attributeName === 'tabindex') {\n          // Re-initialise inert node if tabindex changes\n          this._manageNode(target);\n        } else if (target !== this._rootElement &&\n                   record.attributeName === 'inert' &&\n                   target.hasAttribute('inert')) {\n          // If a new inert root is added, adopt its managed nodes and make sure it knows about the\n          // already managed nodes from this inert subroot.\n          this._adoptInertRoot(target);\n          const inertSubroot = this._inertManager.getInertRoot(target);\n          this._managedNodes.forEach(function(managedNode) {\n            if (target.contains(managedNode.node)) {\n              inertSubroot._manageNode(managedNode.node);\n            }\n          });\n        }\n      }\n    }, this);\n  }\n}\n\n/**\n * `InertNode` initialises and manages a single inert node.\n * A node is inert if it is a descendant of one or more inert root elements.\n *\n * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and\n * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element\n * is intrinsically focusable or not.\n *\n * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an\n * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the\n * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s\n * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,\n * or removes the `tabindex` attribute if the element is intrinsically focusable.\n */\nclass InertNode {\n  /**\n   * @param {!Node} node A focusable element to be made inert.\n   * @param {!InertRoot} inertRoot The inert root element associated with this inert node.\n   */\n  constructor(node, inertRoot) {\n    /** @type {!Node} */\n    this._node = node;\n\n    /** @type {boolean} */\n    this._overrodeFocusMethod = false;\n\n    /**\n     * @type {!Set<!InertRoot>} The set of descendant inert roots.\n     *    If and only if this set becomes empty, this node is no longer inert.\n     */\n    this._inertRoots = new Set([inertRoot]);\n\n    /** @type {?number} */\n    this._savedTabIndex = null;\n\n    /** @type {boolean} */\n    this._destroyed = false;\n\n    // Save any prior tabindex info and make this node untabbable\n    this.ensureUntabbable();\n  }\n\n  /**\n   * Call this whenever this object is about to become obsolete.\n   * This makes the managed node focusable again and deletes all of the previously stored state.\n   */\n  destructor() {\n    this._throwIfDestroyed();\n\n    if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {\n      const element = /** @type {!Element} */ (this._node);\n      if (this._savedTabIndex !== null) {\n        element.setAttribute('tabindex', this._savedTabIndex);\n      } else {\n        element.removeAttribute('tabindex');\n      }\n\n      // Use `delete` to restore native focus method.\n      if (this._overrodeFocusMethod) {\n        delete element.focus;\n      }\n    }\n\n    // See note in InertRoot.destructor for why we cast these nulls to ANY.\n    this._node = /** @type {?} */ (null);\n    this._inertRoots = /** @type {?} */ (null);\n    this._destroyed = true;\n  }\n\n  /**\n   * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.\n   * If the object has been destroyed, any attempt to access it will cause an exception.\n   */\n  get destroyed() {\n    return /** @type {!InertNode} */ (this)._destroyed;\n  }\n\n  /**\n   * Throw if user tries to access destroyed InertNode.\n   */\n  _throwIfDestroyed() {\n    if (this.destroyed) {\n      throw new Error('Trying to access destroyed InertNode');\n    }\n  }\n\n  /** @return {boolean} */\n  get hasSavedTabIndex() {\n    return this._savedTabIndex !== null;\n  }\n\n  /** @return {!Node} */\n  get node() {\n    this._throwIfDestroyed();\n    return this._node;\n  }\n\n  /** @param {?number} tabIndex */\n  set savedTabIndex(tabIndex) {\n    this._throwIfDestroyed();\n    this._savedTabIndex = tabIndex;\n  }\n\n  /** @return {?number} */\n  get savedTabIndex() {\n    this._throwIfDestroyed();\n    return this._savedTabIndex;\n  }\n\n  /** Save the existing tabindex value and make the node untabbable and unfocusable */\n  ensureUntabbable() {\n    if (this.node.nodeType !== Node.ELEMENT_NODE) {\n      return;\n    }\n    const element = /** @type {!Element} */ (this.node);\n    if (matches.call(element, _focusableElementsString)) {\n      if (/** @type {!HTMLElement} */ (element).tabIndex === -1 &&\n          this.hasSavedTabIndex) {\n        return;\n      }\n\n      if (element.hasAttribute('tabindex')) {\n        this._savedTabIndex = /** @type {!HTMLElement} */ (element).tabIndex;\n      }\n      element.setAttribute('tabindex', '-1');\n      if (element.nodeType === Node.ELEMENT_NODE) {\n        element.focus = function() {};\n        this._overrodeFocusMethod = true;\n      }\n    } else if (element.hasAttribute('tabindex')) {\n      this._savedTabIndex = /** @type {!HTMLElement} */ (element).tabIndex;\n      element.removeAttribute('tabindex');\n    }\n  }\n\n  /**\n   * Add another inert root to this inert node's set of managing inert roots.\n   * @param {!InertRoot} inertRoot\n   */\n  addInertRoot(inertRoot) {\n    this._throwIfDestroyed();\n    this._inertRoots.add(inertRoot);\n  }\n\n  /**\n   * Remove the given inert root from this inert node's set of managing inert roots.\n   * If the set of managing inert roots becomes empty, this node is no longer inert,\n   * so the object should be destroyed.\n   * @param {!InertRoot} inertRoot\n   */\n  removeInertRoot(inertRoot) {\n    this._throwIfDestroyed();\n    this._inertRoots.delete(inertRoot);\n    if (this._inertRoots.size === 0) {\n      this.destructor();\n    }\n  }\n}\n\n/**\n * InertManager is a per-document singleton object which manages all inert roots and nodes.\n *\n * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`\n * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.\n * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant\n * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance\n * is created for each such node, via the `_managedNodes` map.\n */\nclass InertManager {\n  /**\n   * @param {!Document} document\n   */\n  constructor(document) {\n    if (!document) {\n      throw new Error('Missing required argument; InertManager needs to wrap a document.');\n    }\n\n    /** @type {!Document} */\n    this._document = document;\n\n    /**\n     * All managed nodes known to this InertManager. In a map to allow looking up by Node.\n     * @type {!Map<!Node, !InertNode>}\n     */\n    this._managedNodes = new Map();\n\n    /**\n     * All inert roots known to this InertManager. In a map to allow looking up by Node.\n     * @type {!Map<!Node, !InertRoot>}\n     */\n    this._inertRoots = new Map();\n\n    /**\n     * Observer for mutations on `document.body`.\n     * @type {!MutationObserver}\n     */\n    this._observer = new MutationObserver(this._watchForInert.bind(this));\n\n    // Add inert style.\n    addInertStyle(document.head || document.body || document.documentElement);\n\n    // Wait for document to be loaded.\n    if (document.readyState === 'loading') {\n      document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));\n    } else {\n      this._onDocumentLoaded();\n    }\n  }\n\n  /**\n   * Set whether the given element should be an inert root or not.\n   * @param {!Element} root\n   * @param {boolean} inert\n   */\n  setInert(root, inert) {\n    if (inert) {\n      if (this._inertRoots.has(root)) { // element is already inert\n        return;\n      }\n\n      const inertRoot = new InertRoot(root, this);\n      root.setAttribute('inert', '');\n      this._inertRoots.set(root, inertRoot);\n      // If not contained in the document, it must be in a shadowRoot.\n      // Ensure inert styles are added there.\n      if (!this._document.body.contains(root)) {\n        let parent = root.parentNode;\n        while (parent) {\n          if (parent.nodeType === 11) {\n            addInertStyle(parent);\n          }\n          parent = parent.parentNode;\n        }\n      }\n    } else {\n      if (!this._inertRoots.has(root)) { // element is already non-inert\n        return;\n      }\n\n      const inertRoot = this._inertRoots.get(root);\n      inertRoot.destructor();\n      this._inertRoots.delete(root);\n      root.removeAttribute('inert');\n    }\n  }\n\n  /**\n   * Get the InertRoot object corresponding to the given inert root element, if any.\n   * @param {!Node} element\n   * @return {!InertRoot|undefined}\n   */\n  getInertRoot(element) {\n    return this._inertRoots.get(element);\n  }\n\n  /**\n   * Register the given InertRoot as managing the given node.\n   * In the case where the node has a previously existing inert root, this inert root will\n   * be added to its set of inert roots.\n   * @param {!Node} node\n   * @param {!InertRoot} inertRoot\n   * @return {!InertNode} inertNode\n   */\n  register(node, inertRoot) {\n    let inertNode = this._managedNodes.get(node);\n    if (inertNode !== undefined) { // node was already in an inert subtree\n      inertNode.addInertRoot(inertRoot);\n    } else {\n      inertNode = new InertNode(node, inertRoot);\n    }\n\n    this._managedNodes.set(node, inertNode);\n\n    return inertNode;\n  }\n\n  /**\n   * De-register the given InertRoot as managing the given inert node.\n   * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert\n   * node from the InertManager's set of managed nodes if it is destroyed.\n   * If the node is not currently managed, this is essentially a no-op.\n   * @param {!Node} node\n   * @param {!InertRoot} inertRoot\n   * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.\n   */\n  deregister(node, inertRoot) {\n    const inertNode = this._managedNodes.get(node);\n    if (!inertNode) {\n      return null;\n    }\n\n    inertNode.removeInertRoot(inertRoot);\n    if (inertNode.destroyed) {\n      this._managedNodes.delete(node);\n    }\n\n    return inertNode;\n  }\n\n  /**\n   * Callback used when document has finished loading.\n   */\n  _onDocumentLoaded() {\n    // Find all inert roots in document and make them actually inert.\n    const inertElements = slice.call(this._document.querySelectorAll('[inert]'));\n    inertElements.forEach(function(inertElement) {\n      this.setInert(inertElement, true);\n    }, this);\n\n    // Comment this out to use programmatic API only.\n    this._observer.observe(this._document.body || this._document.documentElement, {attributes: true, subtree: true, childList: true});\n  }\n\n  /**\n   * Callback used when mutation observer detects attribute changes.\n   * @param {!Array<!MutationRecord>} records\n   * @param {!MutationObserver} self\n   */\n  _watchForInert(records, self) {\n    const _this = this;\n    records.forEach(function(record) {\n      switch (record.type) {\n      case 'childList':\n        slice.call(record.addedNodes).forEach(function(node) {\n          if (node.nodeType !== Node.ELEMENT_NODE) {\n            return;\n          }\n          const inertElements = slice.call(node.querySelectorAll('[inert]'));\n          if (matches.call(node, '[inert]')) {\n            inertElements.unshift(node);\n          }\n          inertElements.forEach(function(inertElement) {\n            this.setInert(inertElement, true);\n          }, _this);\n        }, _this);\n        break;\n      case 'attributes':\n        if (record.attributeName !== 'inert') {\n          return;\n        }\n        const target = /** @type {!Element} */ (record.target);\n        const inert = target.hasAttribute('inert');\n        _this.setInert(target, inert);\n        break;\n      }\n    }, this);\n  }\n}\n\n/**\n * Recursively walk the composed tree from |node|.\n * @param {!Node} node\n * @param {(function (!Element))=} callback Callback to be called for each element traversed,\n *     before descending into child nodes.\n * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.\n */\nfunction composedTreeWalk(node, callback, shadowRootAncestor) {\n  if (node.nodeType == Node.ELEMENT_NODE) {\n    const element = /** @type {!Element} */ (node);\n    if (callback) {\n      callback(element);\n    }\n\n    // Descend into node:\n    // If it has a ShadowRoot, ignore all child elements - these will be picked\n    // up by the <content> or <shadow> elements. Descend straight into the\n    // ShadowRoot.\n    const shadowRoot = /** @type {!HTMLElement} */ (element).shadowRoot;\n    if (shadowRoot) {\n      composedTreeWalk(shadowRoot, callback, shadowRoot);\n      return;\n    }\n\n    // If it is a <content> element, descend into distributed elements - these\n    // are elements from outside the shadow root which are rendered inside the\n    // shadow DOM.\n    if (element.localName == 'content') {\n      const content = /** @type {!HTMLContentElement} */ (element);\n      // Verifies if ShadowDom v0 is supported.\n      const distributedNodes = content.getDistributedNodes ?\n        content.getDistributedNodes() : [];\n      for (let i = 0; i < distributedNodes.length; i++) {\n        composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n      }\n      return;\n    }\n\n    // If it is a <slot> element, descend into assigned nodes - these\n    // are elements from outside the shadow root which are rendered inside the\n    // shadow DOM.\n    if (element.localName == 'slot') {\n      const slot = /** @type {!HTMLSlotElement} */ (element);\n      // Verify if ShadowDom v1 is supported.\n      const distributedNodes = slot.assignedNodes ?\n        slot.assignedNodes({flatten: true}) : [];\n      for (let i = 0; i < distributedNodes.length; i++) {\n        composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n      }\n      return;\n    }\n  }\n\n  // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>\n  // element, nor a <shadow> element recurse normally.\n  let child = node.firstChild;\n  while (child != null) {\n    composedTreeWalk(child, callback, shadowRootAncestor);\n    child = child.nextSibling;\n  }\n}\n\n/**\n * Adds a style element to the node containing the inert specific styles\n * @param {!Node} node\n */\nfunction addInertStyle(node) {\n  if (node.querySelector('style#inert-style')) {\n    return;\n  }\n  const style = document.createElement('style');\n  style.setAttribute('id', 'inert-style');\n  style.textContent = '\\n'+\n                      '[inert] {\\n' +\n                      '  pointer-events: none;\\n' +\n                      '  cursor: default;\\n' +\n                      '}\\n' +\n                      '\\n' +\n                      '[inert], [inert] * {\\n' +\n                      '  user-select: none;\\n' +\n                      '  -webkit-user-select: none;\\n' +\n                      '  -moz-user-select: none;\\n' +\n                      '  -ms-user-select: none;\\n' +\n                      '}\\n';\n  node.appendChild(style);\n}\n\n/** @type {!InertManager} */\nconst inertManager = new InertManager(document);\n\nif (!Element.prototype.hasOwnProperty('inert')) {\n  Object.defineProperty(Element.prototype, 'inert', {\n    enumerable: true,\n    /** @this {!Element} */\n    get: function() {\n      return this.hasAttribute('inert');\n    },\n    /** @this {!Element} */\n    set: function(inert) {\n      inertManager.setInert(this, inert);\n    },\n  });\n}\n"],"names":["_a","_b","_c","_blockingElements","Symbol","_alreadyInertElements","_topElParents","_siblingsToRestore","_parentMO","_topChanged","_swapInertedSibling","_inertSiblings","_restoreInertedSiblings","_getParents","_getDistributedChildren","_isInertable","_handleMutations","BlockingElementsImpl","[object Object]","this","Set","top","elems","length","element","remove","push","i","indexOf","splice","newTop","toKeepInert","oldParents","clear","newParents","parentNode","document","body","Error","toSkip","j","slice","oldInert","newInert","siblingsToRestore","inert","add","has","delete","undefined","elements","disconnect","siblings","sibling","parent","children","inertedSiblings","mo","MutationObserver","bind","parentToObserve","maybeShadyRoot","__shady","host","observe","childList","mutations","parents","mutation","target","idx","inertedChild","removedNodes","console","info","pop","addedNodes","test","localName","current","nodeType","Node","ELEMENT_NODE","assignedSlot","shadowRoot","result","nodes","slots","querySelectorAll","assignedNodes","flatten","$blockingElements","Array","prototype","matches","Element","msMatchesSelector","_focusableElementsString","join","InertRoot","rootElement","inertManager","_inertManager","_rootElement","_managedNodes","hasAttribute","_savedAriaHidden","getAttribute","setAttribute","_makeSubtreeUnfocusable","_observer","_onMutation","attributes","subtree","removeAttribute","forEach","inertNode","_unmanageNode","node","managedNodes","hasSavedAriaHidden","savedAriaHidden","ariaHidden","startNode","composedTreeWalk","_visitNode","activeElement","contains","root","DOCUMENT_FRAGMENT_NODE","blur","focus","_adoptInertRoot","call","_manageNode","register","deregister","inertSubroot","getInertRoot","setInert","savedInertNode","records","self","record","type","_unmanageSubtree","attributeName","managedNode","InertNode","inertRoot","_node","_overrodeFocusMethod","_inertRoots","_savedTabIndex","_destroyed","ensureUntabbable","_throwIfDestroyed","destroyed","hasSavedTabIndex","savedTabIndex","tabIndex","size","destructor","callback","shadowRootAncestor","content","distributedNodes","getDistributedNodes","slot","child","firstChild","nextSibling","addInertStyle","querySelector","style","createElement","textContent","appendChild","_document","Map","_watchForInert","head","documentElement","readyState","addEventListener","_onDocumentLoaded","set","get","addInertRoot","removeInertRoot","inertElement","_this","inertElements","unshift","hasOwnProperty","Object","defineProperty","enumerable"],"mappings":"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"}